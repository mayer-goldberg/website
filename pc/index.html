<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Parsing Combinators in Scheme</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Parsing Combinators in Scheme"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-06-06T22:53+0300"/>
<meta name="author" content="Mayer Goldberg"/>
<meta name="description" content="This document describes Mayer Goldberg's parsing combinator package, written in Scheme, and the various parsers that were written using it. All the necessary files to run the examples and to write new parsers are made available on this page."/>
<meta name="keywords" content="parsing combinators, functional programming, programming languages, lisp, parsing theory, grammars, context-free grammars, CFG, scheme, lambda calculus, Mayer Goldberg, Ben-Gurion University, Department of Computer Science, BGU, BGUCS"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
/**
 *
 * @source: http://orgmode.org/mathjax/MathJax.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 * Copyright (C) 2012  MathJax
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 */

/*
@licstart  The following is the entire license notice for the
JavaScript code below.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code below is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code below.
*/
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Parsing Combinators in Scheme</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 The basic package: <code>parsing-combinators.scm</code></a></li>
<li><a href="#sec-2">2 A scanner &amp; reader for Scheme: <code>parsing-combinators-sexprs.scm</code></a></li>
<li><a href="#sec-3">3 A parser for the &lambda;-calculus: <code>parsing-combinators-lambda.scm</code></a></li>
<li><a href="#sec-4">4 Quo vadis?</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> The basic package: <a href="./files/parsing-combinators.scm"><code>parsing-combinators.scm</code></a></h2>
<div class="outline-text-2" id="text-1">


<p>
Parsing combinators are a technique for implementing top-down, recursive descent parsers in a way that is functional and compositional. The file <code>parsing-combinators.scm</code> implements <i>parsing combinators</i> and a set of supporting procedures for embedding parsers into Scheme. In principle, this is the only file you need to start implementing a parser for your favourite language.
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Basic concepts, and the structure of the parser</h3>
<div class="outline-text-3" id="text-1-1">


<p>
A parser is a closure of the form 
</p>



<pre class="example">(lambda (s match fail)
  ... )
</pre>


<p>
The argument <code>s</code> contains a list of <i>tokens</i>. These can be characters or symbols or numbers or any Scheme object. A parser is written in <i>Continuation-Passing Style</i> (CPS), where each parser takes <i>two</i> continuations, <code>match</code> and <code>fail</code>, corresponding to a standard technique of using <i>success</i> &amp; <i>fail</i> continuations to manage two courses of actions simultaneously. 
</p>
<p>
The parser will then attempt to construct an <i>expression</i> out of the tokens at the head of the list <code>s</code>. If successful, the <code>match</code> continuation will be applied to two arguments: the expression &amp; the remaining tokens. If unsuccessful, the <code>fail</code> continuation will be applied with no arguments.
</p>
<p>
When defining the parser, it is possible to specify procedures that do <i>postprocessing</i> on the expression <i>before</i> it is passed to the <code>match</code> continuation. If you do not specify a postprocessor, the parser will &ldquo;do the right thing&rdquo;, which in most cases means using the <i>identity function</i> for a postprocessor.
</p>
<p>
While parsing combinators are implemented in this package using CPS, you do not need to know or use CPS in order to use this package. Part of the beauty of parsing combinators is that they <i>compose</i> parsers (and are themselves written in CPS), but the expressions the expressions that combine parsing combinators are themselves written in <i>direct style</i>, i.e., do not themselves use CPS.
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> How parsing combinators are used to construct parsers</h3>
<div class="outline-text-3" id="text-1-2">


<p>
Parsing combinators are higher-order functions that compose parsers for smaller languages into parsers for larger languages. The idea is to start with <i>constant</i> parsers, that recognize single tokens, and then combine them using <i>catenation</i>, <i>disjunction</i> and the <i>Kleene Star</i> into larger parsers. 
</p>
<p>
For example, the parser for recognizing the string "<code>fubar</code>" is defined as a catenation of the parsers that recognize the individual characters <code>#\f</code>, <code>#\u</code>, <code>#\b</code>, <code>#\a</code>, &amp; <code>#\r</code>. 
</p>
<p>
Accordingly, the procedures that form the basis for the parsing combinator package are <code>const</code> &ndash; for defining <i>constants</i>, <code>caten</code> &ndash; for returning the <i>catenation</i> parsers, <code>disj</code> &ndash; for returning the <i>disjunction</i> of parsers, and <code>star</code> &ndash; for returning the <i>Kleene Star</i> of a given parser. 
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> The main entry points</h3>
<div class="outline-text-3" id="text-1-3">



</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> <code>test</code></h4>
<div class="outline-text-4" id="text-1-3-1">


<p>
The procedure <code>test</code> is provided so as to simplify testing and debugging of parsers that were written using parsing combinators. It takes 2 arguments:
</p><ol>
<li>A parser
</li>
<li>A list of tokens
</li>
</ol>

<p>It returns a &ldquo;report&rdquo;, which means either the symbol <code>no-match!</code>, in case the parser was not able to construct an expression from the first tokens in the list of tokens, or a list that details the expression the parser had generated and the remaining tokens.
</p>
<p>
The procedure <code>test</code> is not meant as a delivery vehicle for the parser, but rather just for testing. Examples of how <code>test</code> is used will appear throughout this page.
</p>
</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> <code>const</code></h4>
<div class="outline-text-4" id="text-1-3-2">


<p>
The <code>const</code> procedure is how parsers are defined that recognize the simplest expressions &ndash; usually at the level of individual characters. For the sake of generality, <code>const</code> takes a <i>predicate</i> <code>match?</code> and an optional postprocessor <code>cb</code>. If the list of tokens is non-empty &amp; its head satisfies <code>match?</code>, then the head is passed on to the postprocessor, and whatever is returned by the postprocessor is passed onto the <i>success continuation</i> <code>match</code>, along with the remainder of the list of tokens. If the list of tokens is empty, or <code>match?</code> is not satisfied, then the <i>fail continuation</i> <code>fail</code> is called.
</p>
<p>
Here are some examples:
</p>
<p>
The parser <code>p1</code> recognizes the number 37 (how boring is that??). We first call it with a list that does <i>not</i> start with <code>37</code>, and then with a list that does:
</p>



<pre class="example">&gt; (define p1 (const (lambda (x) (and (number? x) (= x 37)))))
&gt; (test p1 '(1 2))
no-match!
&gt; (test p1 '(37 1 2))
((expression: 37) (tokens left: (1 2)))
</pre>


<p>
The parser <code>p2</code> also recognizes the number 37. It is different from <code>p1</code> in that we provide a postprocessor that takes the argument <code>37</code> and replaces with it with the symbol <code>thirty-seven</code>. The difference in the behaviour of <code>p2</code> should be clear:
</p>



<pre class="example">&gt; (define p2 (const (lambda (x) (and (number? x) (= x 37))) (lambda (_) 'thirty-seven)))
&gt; (test p2 '(1 2))
no-match!
 &gt; (test p2 '(37 1 2))
((expression: thirty-seven) (tokens left: (1 2)))
</pre>


</div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> <code>caten</code></h4>
<div class="outline-text-4" id="text-1-3-3">




$$\mathtt{caten}(\mathit{parser}_{G_1}, \ldots, \mathit{parser}_{G_n}) =
 \mathit{parser}_{(G_1 \cdots G_n)} $$

<p>
The <code>caten</code> procedure takes any number of parsers as arguments (it is a <i>variadic</i> procedure), and returns their catenation. For example, if <code>p1</code> recognizes the number 1, <code>p2</code> recognizes the number 2, &amp; <code>p3</code> recognizes the number 3, then the catenation of <code>p1</code>, <code>p2</code>, &amp; <code>p3</code> is a parser that recognizes the numbers 1 2 3, in order, in the start of the list of tokens.
</p>



<pre class="example">&gt; (define number
    (lambda (n)
      (const
       (lambda (x)
         (and (number? x)
              (= x n))))))
&gt; (define p4 ((caten (number 1) (number 2) (number 3))))
&gt; (test p4 '(3 2 1 4))
no-match!
&gt; (test p4 '(1 2 3 4))
((expression: (1 2 3)) (tokens left: (4)))
</pre>


<p>
Notice that in the above example, <code>caten</code> has two pairs of parenthesis around it, that it, the application of <code>caten</code> returns a <i>closure</i> that is applied again. Because <code>caten</code> takes <i>any number</i> of parsers as arguments, and because we wish to be able to specify an additional, optional postprocessor, the simplest solution is to define <code>caten</code> as two nested, variadic procedures: The outermost is applied to the parsers, and returns a variadic closure that can be applied to the optional argument &ndash; the postprocessor. In the above example, we did not pass any postprocessor, which is why the second variadic closure was applied without any arguments.
</p>
<p>
The postprocessor that is used by <code>caten</code> is different from all other postprocessor procedures that are used in this package: All other postprocessors take but one single argument. The postprocessor used by <code>caten</code> takes as many arguments as were concatenated. Here is an example:
</p>



<pre class="example">&gt; (define p5 
    ((caten (number 1) (number 2) (number 3))
     (lambda (a b c)
       `(the tokens begin with ,a ,b and ,c))))
&gt; (test p5 '(hi mom!))
no-match!
&gt; (test p5 '(1 2 3 hi mom!))
((expression: (the tokens begin with 1 2 and 3))
  (tokens left: (hi mom!)))
</pre>


<p>
The motivation behind making <code>conj</code> be variadic, as opposed to binary, is not merely to avoid gratuitous nesting &amp; parenthesis: In the algebra of parsing combinators, the <i>empty conjuction</i>, i.e., the conjuction of zero parsers, is the &epsilon;-parser, i.e., the parser that recognizes &epsilon; (<i>epsilon</i>). This parser does not shorten the list of tokens, and matches the empty list <code>()</code>. So the variadic catenation is both convenient and theoretically-sound, and saves us from having to define yet-another global entry point &ndash; the &epsilon;-parser (which is used in defining the <code>star</code> procedure).
</p>
</div>

</div>

<div id="outline-container-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> <code>disj</code></h4>
<div class="outline-text-4" id="text-1-3-4">




$$\mathtt{disj}(\mathit{parser}_{G_1}, \ldots, \mathit{parser}_{G_n}) =
 \mathit{parser}_{(G_1 \mid \cdots \mid G_n)} $$

<p>
The <code>disj</code> procedure takes any number of parsers as arguments, and returns their disjunction. Starting with the first parser, it attempts to construct an expression out of the list of incoming tokens. If it succeeds, the parser passed the expression and remaining tokens to the <i>success continuation</i> <code>match</code>; If it fails, it moves on to the next parser. If none of the parsers match an initial sublist of the incoming tokens, then the <i>fail continuation</i> <code>fail</code> is applied. The empty disjunction, i.e., the disjunction of zero parsers, is the parser that invokes the <i>fail continuation</i> for any incoming list of tokens.
</p>
<p>
As with <code>caten</code>, the procedure <code>disj</code> is a variadic closure that is applied to any number of parsers, and returns a variadic closure that is applied to an optional postprocessor.
</p>
<p>
Consider the following examples:
</p>



<pre class="example">&gt; (define p6 ((disj (number 3) (number 5) (number 8))))
&gt; (test p6 '())
no-match!
&gt; (test p6 '(2 3 4 5))
no-match!
&gt; (test p6 '(3 4))
((expression: 3) (tokens left: (4)))
&gt; (test p6 '(5 6))
((expression: 5) (tokens left: (6)))
&gt; (test p6 '(8 8 8))
((expression: 8) (tokens left: (8 8)))
</pre>


</div>

</div>

<div id="outline-container-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> <code>star</code></h4>
<div class="outline-text-4" id="text-1-3-5">




$$\mathtt{star}(\mathit{parser}_G) = \mathit{parser}_{(G^{*})} $$

<p>
The <code>star</code> procedure takes a parser <code>p</code> and an optional postprocessor <code>cb</code>, and returns a parser for the grammar that matches lists of zero or more strings matched by <code>p</code>. The resulting list is then passed to the postprocessor, and the return value of the postprocessor, together with the remaining sublist of tokens, is passed to the <i>success continuation</i> <code>match</code>. The parser <code>(star p)</code> always matches some, possibly empty, list, even if <code>p</code> matches nothing.
Consider the following examples:
</p>



<pre class="example">&gt; (define p7 (star (number 23)))
&gt; (test p7 '(2 3 4 5))
((expression: ()) (tokens left: (2 3 4 5)))
&gt; (test p7 '(23 23 23 23 4 5 6))
((expression: (23 23 23 23)) (tokens left: (4 5 6)))
&gt; (define p8 
    (star 
     (const 
      (lambda (ch) 
        (not (and (char-ci&lt;=? #\a ch)
                  (char-ci&lt;=? ch #\z)))))
     ;; pack the punctuation chars:
     (lambda (s) `(punctuation ,(list-&gt;string s)))))
&gt; (test p8 (string-&gt;list "[1] an item..."))
((expression: (punctuation "[1] "))
  (tokens
    left:
    (#\a #\n #\space #\i #\t #\e #\m #\. #\. #\.)))
</pre>


</div>

</div>

<div id="outline-container-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> <code>maybe</code></h4>
<div class="outline-text-4" id="text-1-3-6">




$$\mathtt{maybe}(\mathit{parser}_G) = \mathit{parser}_{(G^{?})}
  = \mathit{parser}_{(\epsilon \mid G)} $$

<p>
The <code>maybe</code> procedures takes a parser <code>p</code> and an optional postprocessor <code>cb</code>, and returns a parser for the grammar that matches either zero or one expressions that are matched by <code>p</code>. It is not the argument that is passed onto the postprocessor, but rather <i>a list containing the argument.</i> If no argument is matched, the postprocessor is passed the empty list. It is therefore possible to test for whether there was zero or one arguments simply by testing for <code>null?</code>. Consider the following examples:
</p>



<pre class="example">&gt; (define p8 (maybe (number 23)))
&gt; (test p8 '())
((expression: ()) (tokens left: ()))
&gt; (test p8 '(2 3 4 5))
((expression: ()) (tokens left: (2 3 4 5)))
&gt; (test p8 '(23 4 5))
((expression: (23)) (tokens left: (4 5)))
&gt; (define p9 (maybe (const null?)))
&gt; (test p9 '())
((expression: ()) (tokens left: ()))
&gt; (test p9 '(()))
((expression: (())) (tokens left: ()))
&gt; (test p9 '(() () ()))
((expression: (())) (tokens left: (() ())))
</pre>


</div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Building extensions</h3>
<div class="outline-text-3" id="text-1-4">




</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> A scanner &amp; reader for Scheme: <a href="./files/parsing-combinators-sexprs.scm"><code>parsing-combinators-sexprs.scm</code></a></h2>
<div class="outline-text-2" id="text-2">


<p>
This file contains an implementation of a <i>reader</i>, i.e., a parser for the grammar of <a href="http://en.wikipedia.org/wiki/S-expression"><i>S-expressions</i></a>. Our reader supports some custom extensions to the syntax of S-expression, so as to demonstrate that the grammar we are parsing is really unrelated to the grammar in which the parser is written &ndash; a distinction that is very clear when the implemented language and the language in which the implementation is written are distinct, but which is blurred when the two languages are the same.
</p>
<p>
Neither do we support the full syntax of S-expressions in Scheme. The main omission is in the <a href="http://en.wikipedia.org/wiki/Numerical_tower"><i>numerical tower</i></a>, out of which we only support integers, signed and unsigned, of arbitrary-precisions. It would make for a nice exercise to extend the reader to handle the full numerical tower of Scheme.
</p>

</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> The main entry points</h3>
<div class="outline-text-3" id="text-2-1">



</div>

<div id="outline-container-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> <code>read-sexpr</code></h4>
<div class="outline-text-4" id="text-2-1-1">


<p>
The procedure <code>read-sexpr</code> is a wrapper around the testing procedure for parsing combinators <code>test</code>. It takes a string, expands it to a list of characters, and passes it to <code>test</code> with the parser <code>&lt;sexpr&gt;</code>. The return value is whatever <code>test</code> returns. Here are some examples:
</p>



<pre class="example">&gt; (load "parsing-combinators-sexprs.scm")
&gt; (read-sexpr "4")
((expression: 4) (tokens left: ()))
&gt; (read-sexpr "4 5")
((expression: 4) (tokens left: (#\space #\5)))
&gt; (read-sexpr "((a . b) #(() #f #\\A) #;(this sexpr will be removed!))")
((expression: ((a . b) #(() #f #\A))) (tokens left: ()))
</pre>


<p>
Note that since <code>read-sexpr</code> takes a string for an argument, some characters cannot be entered without the use of the <i>backslash</i> character (<code>\</code>), which is the most commonly-used meta-character for strings. This means that within a string the character object <code>#\A</code> must be entered as <code>#\\A</code>. String objects within strings must have their matching double quotes prefixed by a backslash.
</p>
<p>
Because <code>read-sexpr</code> uses the <code>&lt;sexpr&gt;</code> parser, it attempts to read only one S-expression. Any remaining characters are left un-consumed in the token stream. This single S-expression, however, can be nested arbitrarily, and include subexpressions that are commented out via the S-expression comment prefix <code>#;</code>. Here is a more complex example to show that the string can be spread across several lines and include different kinds of comments:
</p>



<pre class="example">&gt; (read-sexpr "(;;; This is ignored!
;;; This is another comment line!
first ; this is ignored to the &lt;eoln&gt;!
second #;third
#;(the sexpr comment (can be) (arbitrarily . nested))
)")
((expression: (first second)) (tokens left: ()))
</pre>


</div>

</div>

<div id="outline-container-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> <code>read-sexpr*</code></h4>
<div class="outline-text-4" id="text-2-1-2">


<p>
Similarly to <code>read-sexpr</code>, the procedure <code>read-sexpr*</code> is a wrapper around the testing procedure for parsing combinators <code>test</code>
</p>



<pre class="example">&gt; (read-sexpr* "1 2 3 5 8 13")
((expression: (1 2 3 5 8 13)) (tokens left: ()))
&gt; (read-sexpr* "() (()) #;((())) ()")
((expression: (() (()) ())) (tokens left: ()))
&gt; (read-sexpr* "\"first string\"\"second string\"")
((expression: ("first string" "second string"))
  (tokens left: ()))
</pre>


</div>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Extensions to the syntax of S-expressions</h3>
<div class="outline-text-3" id="text-2-2">


<p>
The language we are parsing need not be identical to the language in which we are implementing the parser! In fact, this is one pedagogical weakness of meta-circular interpreters &ndash; that they blur the distinction between the implementation language and the language being implemented.
</p>
<p>
Therefore, we deem it particularly important, for pedagogical purposes, that we implement a language the syntax of which contains various non-standard extensions to Scheme that are not supported by the host system. Exploiting the fact that the current standard now supports Unicode, we extend the syntax of Scheme to include a variety of special characters:
</p>
<ul>
<li>The Hebrew letter <i>alef</i> (א) is denoted by the named chars <code>#\alef</code> &amp; <code>#\aleph</code>, and within a string, by the meta-chars <code>\{alef}</code> &amp; <code>\{aleph}</code>.
</li>
<li>The Hebrew letter <i>bet</i> (ב) is denoted by the named char <code>#\bet</code>, and within a string, by the meta-char <code>\{bet}</code>.
</li>
<li>The Hebrew letter <i>gimel</i> (ג) is denoted by the named char <code>#\gimel</code>, and within a string, by the meta-char <code>\{gimel}</code>.
</li>
<li>The smiley character (☺) is denoted by the named char <code>#\smiley</code>, and within a string, by the meta-char <code>\{smiley}</code>.
</li>
<li>The Tibetan character for the auspicious sound <a href="http://en.wikipedia.org/wiki/Om"><i>Om</i></a> (ༀ) is denoted by the named char <code>#\tibetan-om</code>, and within a string, by the meta-char <code>\{tibetan-om}</code>.
</li>
<li>The glyph (ﷺ), which stands for the Arabic benediction &rlm;صلى الله عليه وسلم&lrm; (meaning <i>Peace Be Unto Him</i>) is denoted by the named char <code>#\pbuh</code>, and within a string, by the meta-char <code>\{pbuh}</code>.
</li>
</ul>


<p>
Additionally, we extend both characters and strings to support single-byte octal characters, and single &amp; double-byte hexadecimal characters, so in fact, any Unicode character can be represented:
</p>



<pre class="example">&gt; (read-sexpr "(#\\alef #\\tibetan-om . 
                #(\"Peace Be Unto Him: \\{pbuh} \\{smiley}\"))")
((expression: (#\א #\ༀ . #("Peace Be Unto Him: ﷺ ☺")))
  (tokens left: ()))
&gt; (read-sexpr "(#\\x41 #\\x0fc7 #\\o141 \"\\x0f68 \\o041\")")
((expression: (#\A #\࿇ #\a "ཨ !")) (tokens left: ()))
</pre>


</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> A parser for the &lambda;-calculus: <a href="./files/parsing-combinators-lambda.scm"><code>parsing-combinators-lambda.scm</code></a></h2>
<div class="outline-text-2" id="text-3">


<p>
This file contains an implementation of a parser for the &lambda;-calculus. The intention of posting it here, in addition to providing another demonstration of using parsing combinators, is to use the parser as a starting point for proramming projects that concern themselves with the &lambda;-calculus: Reducers of various kinds, etc. In light of this, I strove to make the syntax as inclusive and as general as possible, allowing for many different ways to encode the same &lambda;-expressions.
</p>

</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Entry points</h3>
<div class="outline-text-3" id="text-3-1">



</div>

<div id="outline-container-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Parser for expressions</h4>
<div class="outline-text-4" id="text-3-1-1">


<p>
The parser for reading in expressions is <code>&lt;expr&gt;</code>:
</p>



<pre class="example">&gt; (test &lt;expr&gt; (string-&gt;list "λa b.(a (mul b) c1)"))
((expression:
   (lambda a
     (lambda b
       (applic
         (applic (var a) (applic (var mul) (var b)))
         (lambda s (var s))))))
  (tokens left: ())) 
</pre>


<p>
The syntax for expressions is rich, and includes automatic Currying, left-associativity for applications, and some syntactic sugar to simplify the encoding of &lambda;-expressions. Consult the section on <i>syntactic sugar</i> for additional details.
</p>
</div>

</div>

<div id="outline-container-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> parser for definitions</h4>
<div class="outline-text-4" id="text-3-1-2">


<p>
The parser for reading in definitions is <code>&lt;definition&gt;</code>:
</p>


<pre class="example">&gt; (test &lt;definition&gt; (string-&gt;list "K ::= \\x y.x"))
((expression: (define K (lambda x (lambda y (var x)))))
  (tokens left: ()))
&gt; (test &lt;definition&gt; (string-&gt;list "B ← \\x y z.(x (y z))"))
((expression:
   (define B
     (lambda x
       (lambda y
         (lambda z (applic (var x) (applic (var y) (var z))))))))
  (tokens left: ()))
&gt; (test &lt;definition&gt; (string-&gt;list "K := \\x y.x"))
((expression: (define K (lambda x (lambda y (var x)))))
  (tokens left: ()))
&gt; (test &lt;definition&gt; (string-&gt;list "K :: \\x y.x"))
((expression: (define K (lambda x (lambda y (var x)))))
  (tokens left: ()))
&gt; (test &lt;definition&gt; (string-&gt;list "K ≣ \\x y.x"))
((expression: (define K (lambda x (lambda y (var x)))))
  (tokens left: ()))
&gt; (test &lt;definition&gt; (string-&gt;list "K == \\x y.x"))
((expression: (define K (lambda x (lambda y (var x)))))
  (tokens left: ()))
&gt; (test &lt;definition&gt; (string-&gt;list "K &lt;- \\x y.x"))
((expression: (define K (lambda x (lambda y (var x)))))
  (tokens left: ()))
</pre>


</div>

</div>

<div id="outline-container-3-1-3" class="outline-4">
<h4 id="sec-3-1-3"><span class="section-number-4">3.1.3</span> Parser for files</h4>
<div class="outline-text-4" id="text-3-1-3">


<p>
The parser for reading in complete files is <code>&lt;file&gt;</code>. It reads any number of definitions, load commands, followed by an optional, single expression:
</p>



<pre class="example">&gt; (test &lt;file&gt; (string-&gt;list "

s+ ::= L n s z.(s (n s z))
k ::= L x y . x
f ::= L x y . y
i ::= L x . x
[defs.lc]
m ::= λx.(x x)
(m m)
"))
#&lt;procedure &gt;&gt;
&gt; ((expression:
   ((define s+
      (lambda n
        (lambda s
          (lambda z
            (applic
              (var s)
              (applic (applic (var n) (var s)) (var z))))))) (define k (lambda x (lambda y (var x))))
     (define f (lambda x (lambda y (var y))))
     (define i (lambda x (var x))) (load "defs.lc")
     (define m (lambda x (applic (var x) (var x))))
     (applic (var m) (var m))))
  (tokens left: ()))
</pre>


</div>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Variables</h3>
<div class="outline-text-3" id="text-3-2">


<p>
The syntax for variables roughly follows the syntax of symbols in Scheme. A variable can start with lowercase letter, and be followed by digits and certain punctuation characters. Also, some variables that start with punctuation characters are permitted.
</p>
<p>
Note that some variables are <i>reserved for syntactic sugar</i> and have builtin meaning that cannot be re-defined. Please consult the section on <i>syntactic sugar</i>. 
</p>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Abstractions</h3>
<div class="outline-text-3" id="text-3-3">


<p>
There are many ways to write abstractions in the &lambda;-calculus. We support <code>lambda</code>, <code>lam</code>, and a capital letter <code>L</code>. We also support the backslash (<code>\</code>), though it requires a backslash within a string, an ampersand (<code>&amp;</code>), and the unicode character &lambda;. Please consult the following examples:
</p>



<pre class="example">&gt; (test &lt;expr&gt; (string-&gt;list "\\ x x"))
((expression: (lambda x (var x))) (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "\\ x y z.x"))
((expression: (lambda x (lambda y (lambda z (var x)))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "\\ x.\\y . x"))
((expression: (lambda x (lambda y (var x))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "λ x y z:x"))
((expression: (lambda x (lambda y (lambda z (var x)))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "λ x y z.x"))
((expression: (lambda x (lambda y (lambda z (var x)))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "Lx y z.x"))
((expression: (lambda x (lambda y (lambda z (var x)))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "&amp;x y z.x"))
((expression: (lambda x (lambda y (lambda z (var x)))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "lambda x y z.x"))
((expression: (lambda x (lambda y (lambda z (var x)))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "lam x y z.x"))
((expression: (lambda x (lambda y (lambda z (var x)))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "lambdax y z.x"))
((expression: (lambda x (lambda y (lambda z (var x)))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "lamx y z.x"))
((expression: (lambda x (lambda y (lambda z (var x)))))
  (tokens left: ()))
</pre>


<p>
As you can see in the examples, we tried to make spaces optional where possible. The <i>dot</i> is interchangeable with a <i>colon</i>. 
</p>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Parenthesized expressions &amp; application</h3>
<div class="outline-text-3" id="text-3-4">


<p>
Parentheses are used both for grouping and for delimiting applications. All applications associate to the left:
</p>



<pre class="example">&gt; (test &lt;expr&gt; (string-&gt;list "(((((x)))))"))
((expression: (var x)) (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "(a b c d e)"))
((expression:
   (applic
     (applic (applic (applic (var a) (var b)) (var c)) (var d))
     (var e)))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "(a b c (d e))"))
((expression:
   (applic
     (applic (applic (var a) (var b)) (var c))
     (applic (var d) (var e))))
  (tokens left: ()))
</pre>


</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Syntactic sugar</h3>
<div class="outline-text-3" id="text-3-5">


<p>
Texts on the &lambda;-calculus employ all sorts of abbreviations and meta-notation. This parser recognizes three:
</p>
<ol>
<li>Convenient nation for Church numerals
</li>
<li>Ordered <i>n</i>-tuples
</li>
<li>Projections
</li>
</ol>


<p>
Church numerals &amp; projections can be thought of as referring to special builtin names that have pre-defined values and which cannot be re-defined. Ordered <i>n</i>-tuples are a form of syntactic sugar.
</p>

</div>

<div id="outline-container-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> Church numerals</h4>
<div class="outline-text-4" id="text-3-5-1">


<p>
Church numerals can be written as 
</p>
<ul>
<li>natural numbers (following Church's <i>Calculi of Lambda Conversion</i>),
</li>
<li><code>c3</code>, <code>church10</code>, etc
</li>
<li><code>c_5</code>, <code>church_14</code>, etc
</li>
<li><code>c-1</code>, <code>church-18</code>, etc
</li>
</ul>


<p>
They are expanded into the corresponding &lambda;-expressions. Note that 
\begin{eqnarray*}
c_1 & = & \lambda sz.sz ~=_{\eta}~ \lambda s.s
\end{eqnarray*}
and accordingly, our parser generates <code>(lambda s (var s))</code>.
</p>
<p>
Natural numbers can either be zero, or else they must start with a non-zero digit.
</p>
</div>

</div>

<div id="outline-container-3-5-2" class="outline-4">
<h4 id="sec-3-5-2"><span class="section-number-4">3.5.2</span> Ordered <i>n</i>-tuples</h4>
<div class="outline-text-4" id="text-3-5-2">


<p>
The parser supports the standard syntax for ordered <i>n</i>-tuples, either using square brackets or using angle-brackets:
</p>



<pre class="example">&gt; (test &lt;expr&gt; (string-&gt;list "&lt;a, b, c&gt;"))
((expression:
   (lambda g0
     (applic
       (applic (applic (var g0) (var a)) (var b))
       (var c))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "[a, b, c]"))
((expression:
   (lambda g1
     (applic
       (applic (applic (var g1) (var a)) (var b))
       (var c))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "〈a, b, c〉"))
((expression:
   (lambda g2
     (applic
       (applic (applic (var g2) (var a)) (var b))
       (var c))))
  (tokens left: ()))
</pre>


<p>
The standard encoding for the ordered <i>n</i>-tuples requires a <i>fresh variable</i>, which we create using the <code>gensym</code> procedure. It is possible to encode an <i>n</i>-tuple without a fresh variable, as an application of the <i>n</i>-tuple-maker to the <i>n</i> &lambda;-expressions, but while this definition is &beta;-equivalent to the standard definition, it is significantly more cumbersome. If the use of <code>gensym</code> must be avoided, then you can simply re-define the procedure <code>^n-tuple</code> to the more elaborate definition described above.
</p>
<p>
Note that we support real Unicode angle brackets in addition to the <i>greater than</i> and <i>less than</i> characters that are used to simulate real angle brackets. 
</p>
</div>

</div>

<div id="outline-container-3-5-3" class="outline-4">
<h4 id="sec-3-5-3"><span class="section-number-4">3.5.3</span> Projections</h4>
<div class="outline-text-4" id="text-3-5-3">


<p>
Projections take an ordered <i>n</i>-tuple and return the <i>k</i>-th tuple. This parser allows for a variety of notation, in accordance with the literature on the &lambda;-calculus:
</p>



<pre class="example">&gt; (test &lt;expr&gt; (string-&gt;list "p12"))
((expression:
   (lambda z
     (applic (var z) (lambda x1 (lambda x2 (var x1))))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "p_12"))
((expression:
   (lambda z
     (applic (var z) (lambda x1 (lambda x2 (var x1))))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "p_1_2"))
((expression:
   (lambda z
     (applic (var z) (lambda x1 (lambda x2 (var x1))))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "proj_1_2"))
((expression:
   (lambda z
     (applic (var z) (lambda x1 (lambda x2 (var x1))))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "proj1_2"))
((expression:
   (lambda z
     (applic (var z) (lambda x1 (lambda x2 (var x1))))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "π12"))
((expression:
   (lambda z
     (applic (var z) (lambda x1 (lambda x2 (var x1))))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "π1_2"))
((expression:
   (lambda z
     (applic (var z) (lambda x1 (lambda x2 (var x1))))))
  (tokens left: ()))
&gt; (test &lt;expr&gt; (string-&gt;list "π21"))
((expression:
   (lambda z
     (applic (var z) (lambda x1 (lambda x2 (var x1))))))
  (tokens left: ()))
</pre>


<p>
The last example should make it clear that the order of the <i>n</i> &amp; <i>k</i> is not important, and the parser will interpret this correctly, i.e., take the \(\min(n, k)\) index of the tuple out of an ordered \(\max(n, k)\). Also, a separator is only needed between <i>n</i> &amp; <i>k</i> when they are longer than 1-digit each. 
</p>
</div>
</div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Comments</h3>
<div class="outline-text-3" id="text-3-6">


<p>
Because I envisioned this parser as having to support real work, I tried to invest in flexible syntax for comments.
</p>

</div>

<div id="outline-container-3-6-1" class="outline-4">
<h4 id="sec-3-6-1"><span class="section-number-4">3.6.1</span> Line comments</h4>
<div class="outline-text-4" id="text-3-6-1">


<p>
A line comment start with <code>;</code> or <code>#</code> and goes on until and <i>end-of-line</i> is encountered. These comments are in the spirit of LISP, Scheme, and various shell &amp; scripting languages of the Unix variety.
</p>
</div>

</div>

<div id="outline-container-3-6-2" class="outline-4">
<h4 id="sec-3-6-2"><span class="section-number-4">3.6.2</span> &lambda;-expression comments</h4>
<div class="outline-text-4" id="text-3-6-2">


<p>
Because &lambda;-expressions can span several lines, and because comments are often used to disable a definition, or a part of a definition, rather than to document the code, the parser supports comments at the level of entire &lambda;-expressions. In the spirit of <i>S-expr</i>-comments in Scheme, comments starting with <code>#;</code> disable entire &lambda;-expressions.
</p>
</div>

</div>

<div id="outline-container-3-6-3" class="outline-4">
<h4 id="sec-3-6-3"><span class="section-number-4">3.6.3</span> XML comments</h4>
<div class="outline-text-4" id="text-3-6-3">


<p>
To comment-out large areas of code, we support the XML tags <code>&lt;comment&gt; ... &lt;/comment&gt;</code>. Anything in between is commented out. Note, however, that XML comments cannot be nested.
</p>
</div>
</div>

</div>

<div id="outline-container-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Loading files</h3>
<div class="outline-text-3" id="text-3-7">


<p>
The <code>&lt;file&gt;</code> parser supports syntax for specifying the names of files that should be loaded &mdash; presumably files with definitions of various terms. The syntax is diverse:
</p>



<pre class="example">&gt; (test &lt;file&gt; (string-&gt;list "
(load \"foo-1.lc\")
load [foo-2.lc]
'foo-3.lc'
[foo-4.lc]
\"foo-5.lc\"
"))
((expression:
   ((load "foo-1.lc")
     (load "foo-2.lc")
     (load "foo-3.lc")
     (load "foo-4.lc")
     (load "foo-5.lc")))
  (tokens left: ()))
</pre>


<p>
The rationale for supporting different ways of specifying a filename is that it is inconvenient to use double quotes within strings, because they must be preceeded by a backslash character. So we support the Scheme/LISP/C conventions for strings, as well as the Pascal convention (of using single quotes), as well as a bracket version.
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Quo vadis?</h2>
<div class="outline-text-2" id="text-4">



</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2013-06-06T22:53+0300</p>
<p class="author">Author: Mayer Goldberg</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
